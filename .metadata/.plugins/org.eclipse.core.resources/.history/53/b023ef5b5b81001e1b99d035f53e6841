import java.awt.EventQueue;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Vector;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;

public class ArcadeServer extends JFrame {
	private BufferedReader in = null;
	private BufferedWriter out = null;
	private ServerSocket listener = null; // 서버 소켓
	private Socket socket = null; // 클라이언트 소켓 (클라.accept로 생성된 소켓)
	private Vector UserVec = new Vector(); // 연결된 사용자를 저장할 벡터
	
	private JPanel contentPane;
	private JTextArea textArea;
	private JTextField txtPortNumber;
	
	int width = 600;
	int height = 600;
	int port = 9999;
	int clientId = 0;
	
	public static void main(String[] args) {
		ArcadeServer server = new ArcadeServer();
	}
	

	
	public ArcadeServer() { //생성자
		//ArcadeServer server = this;
		setTitle("서버 로그");
		setLocation(0,0);
		setSize(width,height);
		setLayout(null);
		setVisible(true);
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		// 서버 정보 라벨
		JLabel serverInfoLabel = new JLabel();
		serverInfoLabel.setSize(width,100);
		serverInfoLabel.setLocation(10,10);
		serverInfoLabel.setText("<html>"
				+ "<h1>크레이지아케이드 서버</h1><hr/>"
				+ "<p>서버 실행을 담당하고 클라이언트 정보를 얻어옵니다.</p>"
				+ "<p>서버는 9999 포트에서 시작됩니다.</p>"
				+ "</html>");
		add(serverInfoLabel);
		
		// 서버 및 클라이언트 정보를 기록할 텍스트 영역
		textArea = new JTextArea();
		textArea.setLocation(10,120);
		textArea.setSize(width-50,height-280);
		textArea.setEditable(false);
		add(textArea);
		
		// 서버 실행 버튼
		JButton btnServerStart = new JButton("Server Start");
		btnServerStart.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				
				// 서버 소켓 생성
				try {
					listener = new ServerSocket(port);
				} catch (IOException e1) {
					e1.printStackTrace();
				}
				AppendText("서버가 "+port+" 포트에서 실행중입니다.");
				btnServerStart.setEnabled(false); // 서버를 더이상 실행시키지 못 하게 막는다
				
				// 서버 스레드 수행, 클라이언트 접속을 waiting..
				ServerThread serverThread = new ServerThread();
				serverThread.start();
			}
		});
		btnServerStart.setSize(300,50);
		btnServerStart.setLocation(width/2 - 300/2,height-110);
		this.add(btnServerStart);
		
		this.repaint();
	}
	
	void AppendText(String s) {
		textArea.append(s + "\n");
		textArea.setCaretPosition(textArea.getText().length());
	}
	
	class ServerThread extends Thread{
		@Override
		public void run() {
			while (true) { // 사용자 접속을 계속해서 받기 위해 while문
				try {
					AppendText("클라이언트 접속을 대기중입니다.");
					socket = listener.accept(); // accept가 일어나기 전까지는 무한 대기중
					AppendText("새로운 참가자 from " + socket);
					
					// User 당 하나씩 수신 할 수 있는 Thread 생성
					clientId++;
					ServerReceiver new_user = new ServerReceiver(socket, clientId);
					UserVec.add(new_user); // 새로운 참가자 배열에 추가
					new_user.start(); // 만든 객체의 스레드 실행
					AppendText("현재 동접자 수 :" + UserVec.size());
				} catch (IOException e) {
					AppendText("accept() error");
					// System.exit(0);
				}
			}
		}
		
		class ServerReceiver extends Thread {// User 스레드
			private BufferedReader in;
			private BufferedWriter out;
			private Socket clientSocket;
			private int clientId;
			private Vector user_vc;
			public String UserName = "";
			public String UserStatus;
	
			public ServerReceiver(Socket s, int clientId) {
				this.clientSocket = s;
				this.clientId = clientId;
				this.user_vc = UserVec;
				try {
					in = new BufferedReader(new InputStreamReader(s.getInputStream()));
					out = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
				} catch (Exception e) {
					AppendText("에?러");
				}
			}
			
			public void SendToAll(String msg) {
				System.out.println("?");
				try {
					out.write(msg+"\n");
					out.flush();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			
			@Override
			public void run() {

				String message = null;
				
				int msgType = 0;
				String msgContent = null;
				
				while(true) {
					
					try {
						message = in.readLine();
						if (message == null) {
							break;
						}
					} catch (Exception e) {
						System.out.println(e.getMessage());
						//System.exit(1);
					}
					// 클라이언트로부터 메세지를 얻어온다. 이때 메세지는 타입에 따라 다른 행동을 한다.
					// 여기서 메세지는 아래 예시처럼 "//"으로 타입과 메세지를 구분한다.
					// 1은 클라이언트가 서버에 접속한 경우,  -  "1/로그인했습니다"
					// 2는 클라이언트가 채팅방에 메시지를 입력하는 경우,  -  "2/유저 1 : 안녕하세요"
					System.out.println(message);
					
					msgType = Integer.parseInt(message.split("/")[0]);
					msgContent = message.split("/")[1];
						
					switch(msgType) {
					case 1:
						AppendText("클라이언트 "+clientId+" 로그인");
						clientId++;
						break;
					case 2:
						AppendText("클라이언트 "+clientId+" 채팅 : "+msgContent);
						break;
					case 3:
						System.out.println("클라이언트가 방 생성");
						try {
							out.write("서버에서 보낸 메세지"+"\n");
							out.flush();
						} catch (IOException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						break;
					default:
						break;
				}
			}
		}
	}
}}
